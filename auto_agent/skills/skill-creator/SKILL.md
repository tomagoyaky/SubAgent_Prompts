---
name: skill-creator
description: 用于创建有效技能的指南。当用户想要创建一个新技能（或更新现有技能）来扩展Agent的能力，添加专业知识、工作流或工具集成时，应该使用此技能。
license: 完整条款请参见LICENSE.txt
---

# 技能创建者

本技能提供了创建有效技能的指导。

## 关于技能

技能是模块化、自包含的包，通过提供专业知识、工作流和工具来扩展Agent的能力。可以将它们视为特定领域或任务的"入职指南"——它们将Agent从一个通用智能体转变为一个配备了模型无法完全拥有的程序化知识的专业智能体。

### 技能提供什么

1. 专业工作流 - 特定领域的多步骤程序
2. 工具集成 - 用于处理特定文件格式或API的说明
3. 领域专业知识 - 公司特定知识、模式、业务逻辑
4. 捆绑资源 - 用于复杂和重复任务的脚本、参考资料和资产

## 核心原则

### 简洁是关键

上下文窗口是一种公共资源。技能与Agent需要的其他所有内容共享上下文窗口：系统提示、对话历史、其他技能的元数据以及实际用户请求。

**默认假设：Agent已经非常聪明。** 只添加Agent尚未拥有的上下文。挑战每一条信息："Agent真的需要这个解释吗？"和"这一段是否值得其令牌成本？"

优先选择简洁的示例，而不是冗长的解释。

### 设置适当的自由度

根据任务的脆弱性和可变性匹配具体程度：

**高度自由（基于文本的指令）**：当多种方法有效、决策依赖于上下文或启发式指导方法时使用。

**中度自由（伪代码或带参数的脚本）**：当存在首选模式、允许一些变化或配置影响行为时使用。

**低度自由（特定脚本，少数参数）**：当操作脆弱且容易出错、一致性至关重要或必须遵循特定顺序时使用。

将Agent视为探索路径：悬崖边的狭窄桥梁需要特定的护栏（低度自由），而开阔的田野允许许多路线（高度自由）。

### 技能的结构

每个技能由一个必需的SKILL.md文件和可选的捆绑资源组成：

```
skill-name/
├── SKILL.md (必需)
│   ├── YAML前置元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown说明 (必需)
└── 捆绑资源 (可选)
    ├── scripts/          - 可执行代码 (Python/Bash等)
    ├── references/       - 必要时加载到上下文中的文档
    └── assets/           - 输出中使用的文件（模板、图标、字体等）
```

#### SKILL.md (必需)

每个SKILL.md包含：

- **前置元数据（YAML）**：包含`name`和`description`字段。这些是Agent用来确定何时使用该技能的唯一字段，因此清晰全面地描述技能是什么以及何时应该使用它非常重要。
- **主体（Markdown）**：使用技能的说明和指导。仅在技能触发后加载（如果有的话）。

#### 捆绑资源（可选）

##### 脚本 (`scripts/`)

可执行代码（Python/Bash等），用于需要确定性可靠性或反复重写的任务。

- **何时包含**：当相同的代码被反复重写或需要确定性可靠性时
- **示例**：`scripts/rotate_pdf.py` 用于PDF旋转任务
- **好处**：令牌高效、确定性、可以在不加载到上下文的情况下执行
- **注意事项**：Agent可能仍需要阅读脚本来进行修补或环境特定调整

##### 参考资料 (`references/`)

文档和参考资料，旨在在需要时加载到上下文中，为Agent的过程和思考提供信息。

- **何时包含**：当Agent在工作时需要参考文档时
- **示例**：`references/finance.md` 用于财务模式，`references/mnda.md` 用于公司NDA模板，`references/policies.md` 用于公司政策，`references/api_docs.md` 用于API规范
- **用例**：数据库模式、API文档、领域知识、公司政策、详细工作流指南
- **好处**：保持SKILL.md简洁，仅在Agent确定需要时加载
- **最佳实践**：如果文件较大（>10k字），在SKILL.md中包含grep搜索模式
- **避免重复**：信息应该存在于SKILL.md或参考文件中，而不是两者都有。除非确实是技能的核心，否则优先使用参考文件来存储详细信息——这可以保持SKILL.md简洁，同时使信息可发现而不占用上下文窗口。只在SKILL.md中保留必要的程序指令和工作流指导；将详细参考材料、模式和示例移至参考文件。

##### 资产 (`assets/`)

不打算加载到上下文中，而是用于Agent生成的输出中的文件。

- **何时包含**：当技能需要在最终输出中使用文件时
- **示例**：`assets/logo.png` 用于品牌资产，`assets/slides.pptx` 用于PowerPoint模板，`assets/frontend-template/` 用于HTML/React样板，`assets/font.ttf` 用于排版
- **用例**：模板、图像、图标、样板代码、字体、被复制或修改的示例文档
- **好处**：将输出资源与文档分离，使Agent能够使用文件而无需将其加载到上下文中

#### 技能中不应包含的内容

技能应仅包含直接支持其功能的必要文件。不要创建无关的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等等

技能应仅包含AI智能体完成手头工作所需的信息。不应包含关于创建过程的辅助上下文、设置和测试程序、面向用户的文档等。创建额外的文档文件只会增加混乱和困惑。

### 渐进式披露设计原则

技能使用三级加载系统来高效管理上下文：

1. **元数据（名称+描述）** - 始终在上下文中 (~100字)
2. **SKILL.md主体** - 当技能触发时 (<5k字)
3. **捆绑资源** - 按需由Agent加载（无限制，因为脚本可以在不读取到上下文窗口的情况下执行）

#### 渐进式披露模式

将SKILL.md主体保持在必要内容和500行以下，以最小化上下文膨胀。当接近此限制时，将内容拆分为单独的文件。当将内容拆分到其他文件时，非常重要的是从SKILL.md引用它们并清楚地描述何时读取它们，以确保技能的读者知道它们的存在和使用时机。

**关键原则**：当技能支持多种变体、框架或选项时，只在SKILL.md中保留核心工作流和选择指导。将变体特定的详细信息（模式、示例、配置）移至单独的参考文件。

**模式1：带有参考资料的高级指南**

```markdown
# PDF处理

## 快速开始

使用pdfplumber提取文本：
[代码示例]

## 高级功能

- **表单填充**：请参阅[FORMS.md](FORMS.md)获取完整指南
- **API参考**：请参阅[REFERENCE.md](REFERENCE.md)获取所有方法
- **示例**：请参阅[EXAMPLES.md](EXAMPLES.md)获取常见模式
```

Agent仅在需要时加载FORMS.md、REFERENCE.md或EXAMPLES.md。

**模式2：特定领域组织**

对于具有多个领域的技能，按领域组织内容以避免加载无关上下文：

```
bigquery-skill/
├── SKILL.md (概述和导航)
└── reference/
    ├── finance.md (收入、计费指标)
    ├── sales.md (机会、销售漏斗)
    ├── product.md (API使用、功能)
    └── marketing.md (活动、归因)
```

当用户询问销售指标时，Agent只会读取sales.md。

同样，对于支持多个框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md (工作流+提供商选择)
└── references/
    ├── aws.md (AWS部署模式)
    ├── gcp.md (GCP部署模式)
    └── azure.md (Azure部署模式)
```

当用户选择AWS时，Agent只会读取aws.md。

**模式3：条件详细信息**

显示基本内容，链接到高级内容：

```markdown
# DOCX处理

## 创建文档

使用docx-js创建新文档。请参阅[DOCX-JS.md](DOCX-JS.md)。

## 编辑文档

对于简单编辑，直接修改XML。

**对于修订跟踪**：请参阅[REDLINING.md](REDLINING.md)
**对于OOXML详细信息**：请参阅[OOXML.md](OOXML.md)
```

Agent仅在用户需要这些功能时读取REDLINING.md或OOXML.md。

**重要指南**：

- **避免深度嵌套参考** - 保持参考与SKILL.md的一级深度。所有参考文件应直接链接自SKILL.md。
- **结构化较长的参考文件** - 对于超过100行的文件，在顶部包含目录，以便Agent在预览时可以看到完整范围。

## 技能创建流程

技能创建涉及以下步骤：

1. 通过具体示例理解技能
2. 规划可重用的技能内容（脚本、参考资料、资产）
3. 初始化技能（运行init_skill.py）
4. 编辑技能（实现资源并编写SKILL.md）
5. 打包技能（运行package_skill.py）
6. 根据实际使用情况迭代

按顺序遵循这些步骤，仅当有明确理由不适用时才跳过。

### 步骤1：通过具体示例理解技能

仅当技能的使用模式已经明确理解时才跳过此步骤。即使使用现有技能，它仍然很有价值。

要创建有效的技能，清楚地理解技能将如何被使用的具体示例。这种理解可以来自直接的用户示例或经过用户反馈验证的生成示例。

例如，在构建图像编辑器技能时，相关问题包括：

- "图像编辑器技能应支持哪些功能？编辑、旋转，还有其他吗？"
- "你能给出一些这个技能将如何被使用的例子吗？"
- "我可以想象用户要求'从这张图像中移除红眼'或'旋转这张图像'。你能想象这个技能还有其他使用方式吗？"
- "用户会说什么来触发这个技能？"

为了避免使用户不知所措，避免在单个消息中询问太多问题。从最重要的问题开始，根据需要跟进以提高有效性。

当对技能应支持的功能有清晰的认识时，结束此步骤。

### 步骤2：规划可重用的技能内容

要将具体示例转化为有效的技能，分析每个示例：

1. 考虑如何从头开始执行示例
2. 确定在重复执行这些工作流时哪些脚本、参考资料和资产会有帮助

示例：当构建一个`pdf-editor`技能来处理像"帮我旋转这个PDF"这样的查询时，分析显示：

1. 旋转PDF需要每次重写相同的代码
2. 一个`scripts/rotate_pdf.py`脚本将有助于存储在技能中

示例：当设计一个`frontend-webapp-builder`技能来处理像"为我构建一个待办应用"或"为我构建一个仪表板来跟踪我的步数"这样的查询时，分析显示：

1. 编写前端Web应用每次都需要相同的样板HTML/React
2. 一个包含样板HTML/React项目文件的`assets/hello-world/`模板将有助于存储在技能中

示例：当构建一个`big-query`技能来处理像"今天有多少用户登录？"这样的查询时，分析显示：

1. 查询BigQuery需要每次重新发现表模式和关系
2. 一个记录表模式的`references/schema.md`文件将有助于存储在技能中

要建立技能的内容，分析每个具体示例，创建一个要包含的可重用资源列表：脚本、参考资料和资产。

### 步骤3：初始化技能

此时，是时候实际创建技能了。

仅当正在开发的技能已经存在，并且需要迭代或打包时才跳过此步骤。在这种情况下，继续下一步。

当从头创建新技能时，始终运行`init_skill.py`脚本。该脚本方便地生成一个新的模板技能目录，自动包含技能所需的一切，使技能创建过程更加高效和可靠。

用法：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

该脚本：

- 在指定路径创建技能目录
- 生成带有适当前置元数据和TODO占位符的SKILL.md模板
- 创建示例资源目录：`scripts/`、`references/`和`assets/`
- 在每个目录中添加可自定义或删除的示例文件

初始化后，根据需要自定义或删除生成的SKILL.md和示例文件。

### 步骤4：编辑技能

当编辑（新生成或现有）技能时，请记住技能是为Agent的另一个实例使用而创建的。包含对Agent有益且不明显的信息。考虑哪些程序知识、领域特定详细信息或可重用资产将帮助另一个Agent实例更有效地执行这些任务。

#### 学习经过验证的设计模式

根据您的技能需求参考这些有用的指南：

- **多步骤流程**：请参阅references/workflows.md获取顺序工作流和条件逻辑
- **特定输出格式或质量标准**：请参阅references/output-patterns.md获取模板和示例模式

这些文件包含有效技能设计的既定最佳实践。

#### 从可重用的技能内容开始

要开始实施，从上面确定的可重用资源开始：`scripts/`、`references/`和`assets/`文件。请注意，此步骤可能需要用户输入。例如，当实施`brand-guidelines`技能时，用户可能需要提供品牌资产或模板存储在`assets/`中，或提供文档存储在`references/`中。

添加的脚本必须通过实际运行来测试，以确保没有bug并且输出符合预期。如果有许多类似的脚本，只需要测试代表性样本，以确保在平衡完成时间的同时，有信心它们都能工作。

任何不需要的示例文件和目录都应删除。初始化脚本在`scripts/`、`references/`和`assets/`中创建示例文件以演示结构，但大多数技能不需要所有这些文件。

#### 更新SKILL.md

**写作指南**：始终使用命令式/不定式形式。

##### 前置元数据

使用`name`和`description`编写YAML前置元数据：

- `name`：技能名称
- `description`：这是您技能的主要触发机制，有助于Agent理解何时使用该技能。
  - 包括技能的功能和使用它的特定触发条件/上下文。
  - 所有"何时使用"信息都应在这里 - 而不是在主体中。主体仅在触发后加载，因此主体中的"何时使用此技能"部分对Agent没有帮助。
  - `docx`技能的描述示例："全面的文档创建、编辑和分析，支持修订跟踪、注释、格式保留和文本提取。当Agent需要处理专业文档（.docx文件）时使用：(1) 创建新文档，(2) 修改或编辑内容，(3) 使用修订跟踪，(4) 添加注释，或任何其他文档任务"

不要在YAML前置元数据中包含任何其他字段。

##### 主体

编写使用技能及其捆绑资源的说明。

### 步骤5：打包技能

技能开发完成后，必须将其打包成可分发的.skill文件，与用户共享。打包过程会先自动验证技能，确保它符合所有要求：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可选的输出目录指定：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **验证** 自动验证技能，检查：

   - YAML前置元数据格式和必需字段
   - 技能命名约定和目录结构
   - 描述的完整性和质量
   - 文件组织和资源引用

2. **打包** 如果验证通过，则创建一个以技能命名的.skill文件（例如，`my-skill.skill`），包含所有文件并为分发维护适当的目录结构。.skill文件是一个带有.skill扩展名的zip文件。

如果验证失败，脚本将报告错误并退出，不创建包。修复任何验证错误并再次运行打包命令。

### 步骤6：迭代

测试技能后，用户可能会要求改进。这通常发生在使用技能后不久，有关于技能表现的新鲜上下文。

**迭代工作流**：

1. 在实际任务上使用技能
2. 注意挣扎或低效之处
3. 确定SKILL.md或捆绑资源应如何更新
4. 实施更改并再次测试